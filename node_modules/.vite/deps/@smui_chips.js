import {
  deprecated_exports
} from "./chunk-OJIEB3RT.js";
import {
  dist_default
} from "./chunk-RFVT3V65.js";
import "./chunk-CTXZTH3U.js";
import {
  ContextFragment_default,
  SmuiElement_default
} from "./chunk-ZRO6H3MF.js";
import {
  announce,
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-SJMHMZA4.js";
import "./chunk-6A2TAOKG.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-Q6FUYFY3.js";
import "./chunk-LM6G6BDY.js";
import "./chunk-I52LNARA.js";
import "./chunk-N2TCLGKF.js";
import "./chunk-7TL3QSXI.js";
import "./chunk-E3PZ3JEK.js";
import {
  writable
} from "./chunk-E6ZP6LG5.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  space,
  svg_element,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import "./chunk-5WWUZCGV.js";

// node_modules/@smui/chips/dist/Chip.svelte
var { Error: Error_1 } = globals;
var file = "node_modules\\@smui\\chips\\dist\\Chip.svelte";
function create_if_block_1(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-chip__ripple");
      add_location(div, file, 48, 4, 1531);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(48:2) {#if ripple && !$nonInteractive}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-chip__touch");
      add_location(div, file, 52, 4, 1601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(52:2) {#if touch}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*ripple*/
    ctx[3] && !/*$nonInteractive*/
    ctx[14] && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[38],
    null
  );
  let if_block1 = (
    /*touch*/
    ctx[4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ripple*/
        ctx2[3] && !/*$nonInteractive*/
        ctx2[14]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[38],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[38]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[38],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*touch*/
        ctx2[4]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[     [       Ripple,       {         ripple: ripple && !$nonInteractive,         unbounded: false,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-chip': true,     'mdc-chip--selected': selected,     'mdc-chip--touch': touch,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   role=\\\"row\\\"   on:transitionend={instance && instance.handleTransitionEnd.bind(instance)}   on:click={instance && instance.handleClick.bind(instance)}   on:keydown={instance && instance.handleKeydown.bind(instance)}   on:focusin={instance && instance.handleFocusIn.bind(instance)}   on:focusout={instance && instance.handleFocusOut.bind(instance)}   on:SMUIChipTrailingAction:interaction={instance &&     instance.handleTrailingActionInteraction.bind(instance)}   on:SMUIChipTrailingAction:navigation={instance &&     instance.handleTrailingActionNavigation.bind(instance)}   on:SMUIChipsChipPrimaryAction:mount={handleSMUIChipsChipPrimaryAction}   on:SMUIChipsChipPrimaryAction:unmount={() =>     (primaryActionAccessor = undefined)}   on:SMUIChipsChipTrailingAction:mount={handleSMUIChipsChipTrailingAction}   on:SMUIChipsChipTrailingAction:unmount={() =>     (trailingActionAccessor = undefined)}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[6]
    ) },
    {
      use: [
        [
          dist_default,
          {
            ripple: (
              /*ripple*/
              ctx[3] && !/*$nonInteractive*/
              ctx[14]
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[25]
            ),
            removeClass: (
              /*removeClass*/
              ctx[26]
            ),
            addStyle: (
              /*addStyle*/
              ctx[27]
            )
          }
        ],
        /*forwardEvents*/
        ctx[15],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip": true,
        "mdc-chip--selected": (
          /*selected*/
          ctx[8]
        ),
        "mdc-chip--touch": (
          /*touch*/
          ctx[4]
        ),
        .../*internalClasses*/
        ctx[10]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        ctx[11]
      ).map(func).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    { role: "row" },
    /*$$restProps*/
    ctx[28]
  ];
  var switch_value = (
    /*component*/
    ctx[5]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[35](switch_instance);
    switch_instance.$on("transitionend", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTransitionEnd.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTransitionEnd.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("click", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleClick.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleClick.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("keydown", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleKeydown.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleKeydown.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("focusin", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleFocusIn.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleFocusIn.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("focusout", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleFocusOut.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleFocusOut.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("SMUIChipTrailingAction:interaction", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTrailingActionInteraction.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTrailingActionInteraction.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("SMUIChipTrailingAction:navigation", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTrailingActionNavigation.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTrailingActionNavigation.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on(
      "SMUIChipsChipPrimaryAction:mount",
      /*handleSMUIChipsChipPrimaryAction*/
      ctx[23]
    );
    switch_instance.$on(
      "SMUIChipsChipPrimaryAction:unmount",
      /*SMUIChipsChipPrimaryAction_unmount_handler*/
      ctx[36]
    );
    switch_instance.$on(
      "SMUIChipsChipTrailingAction:mount",
      /*handleSMUIChipsChipTrailingAction*/
      ctx[24]
    );
    switch_instance.$on(
      "SMUIChipsChipTrailingAction:unmount",
      /*SMUIChipsChipTrailingAction_unmount_handler*/
      ctx[37]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = dirty[0] & /*tag, ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use, className, selected, touch, internalClasses, internalStyles, style, $$restProps*/
      503369055 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*tag*/
        64 && { tag: (
          /*tag*/
          ctx[6]
        ) },
        dirty[0] & /*ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use*/
        234930185 && {
          use: [
            [
              dist_default,
              {
                ripple: (
                  /*ripple*/
                  ctx[3] && !/*$nonInteractive*/
                  ctx[14]
                ),
                unbounded: false,
                addClass: (
                  /*addClass*/
                  ctx[25]
                ),
                removeClass: (
                  /*removeClass*/
                  ctx[26]
                ),
                addStyle: (
                  /*addStyle*/
                  ctx[27]
                )
              }
            ],
            /*forwardEvents*/
            ctx[15],
            .../*use*/
            ctx[0]
          ]
        },
        dirty[0] & /*className, selected, touch, internalClasses*/
        1298 && {
          class: classMap({
            [
              /*className*/
              ctx[1]
            ]: true,
            "mdc-chip": true,
            "mdc-chip--selected": (
              /*selected*/
              ctx[8]
            ),
            "mdc-chip--touch": (
              /*touch*/
              ctx[4]
            ),
            .../*internalClasses*/
            ctx[10]
          })
        },
        dirty[0] & /*internalStyles, style*/
        2052 && {
          style: Object.entries(
            /*internalStyles*/
            ctx[11]
          ).map(func).concat([
            /*style*/
            ctx[2]
          ]).join(" ")
        },
        switch_instance_spread_levels[4],
        dirty[0] & /*$$restProps*/
        268435456 && get_spread_object(
          /*$$restProps*/
          ctx[28]
        )
      ]) : {};
      if (dirty[0] & /*touch, ripple, $nonInteractive*/
      16408 | dirty[1] & /*$$scope*/
      128) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty[0] & /*component*/
      32 && switch_value !== (switch_value = /*component*/
      ctx[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          ctx[35](switch_instance);
          switch_instance.$on("transitionend", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTransitionEnd.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTransitionEnd.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("click", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleClick.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleClick.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("keydown", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleKeydown.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleKeydown.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("focusin", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleFocusIn.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleFocusIn.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("focusout", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleFocusOut.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleFocusOut.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("SMUIChipTrailingAction:interaction", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTrailingActionInteraction.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTrailingActionInteraction.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("SMUIChipTrailingAction:navigation", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTrailingActionNavigation.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTrailingActionNavigation.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on(
            "SMUIChipsChipPrimaryAction:mount",
            /*handleSMUIChipsChipPrimaryAction*/
            ctx[23]
          );
          switch_instance.$on(
            "SMUIChipsChipPrimaryAction:unmount",
            /*SMUIChipsChipPrimaryAction_unmount_handler*/
            ctx[36]
          );
          switch_instance.$on(
            "SMUIChipsChipTrailingAction:mount",
            /*handleSMUIChipsChipTrailingAction*/
            ctx[24]
          );
          switch_instance.$on(
            "SMUIChipsChipTrailingAction:unmount",
            /*SMUIChipsChipTrailingAction_unmount_handler*/
            ctx[37]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[35](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "chip",
    "ripple",
    "touch",
    "shouldRemoveOnTrailingIconClick",
    "shouldFocusPrimaryActionOnClick",
    "component",
    "tag",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $index;
  let $choice;
  let $leadingIconClassesStore;
  let $isSelectedStore;
  let $shouldRemoveOnTrailingIconClickStore;
  let $initialSelectedStore;
  let $nonInteractive;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chip", slots, ["default"]);
  const { MDCChipFoundation } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { chip: chipId } = $$props;
  let { ripple = true } = $$props;
  let { touch = false } = $$props;
  let { shouldRemoveOnTrailingIconClick = true } = $$props;
  let { shouldFocusPrimaryActionOnClick = true } = $$props;
  let element2;
  let instance5;
  let internalClasses = {};
  let leadingIconClasses = {};
  let internalStyles = {};
  const initialSelectedStore = getContext("SMUI:chips:chip:initialSelected");
  validate_store(initialSelectedStore, "initialSelectedStore");
  component_subscribe($$self, initialSelectedStore, (value) => $$invalidate(44, $initialSelectedStore = value));
  let selected = $initialSelectedStore;
  let primaryActionAccessor = void 0;
  let trailingActionAccessor = void 0;
  const nonInteractive = getContext("SMUI:chips:nonInteractive");
  validate_store(nonInteractive, "nonInteractive");
  component_subscribe($$self, nonInteractive, (value) => $$invalidate(14, $nonInteractive = value));
  const choice = getContext("SMUI:chips:choice");
  validate_store(choice, "choice");
  component_subscribe($$self, choice, (value) => $$invalidate(40, $choice = value));
  const index = getContext("SMUI:chips:chip:index");
  validate_store(index, "index");
  component_subscribe($$self, index, (value) => $$invalidate(39, $index = value));
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? "div" : void 0 } = $$props;
  const shouldRemoveOnTrailingIconClickStore = writable(shouldRemoveOnTrailingIconClick);
  validate_store(shouldRemoveOnTrailingIconClickStore, "shouldRemoveOnTrailingIconClickStore");
  component_subscribe($$self, shouldRemoveOnTrailingIconClickStore, (value) => $$invalidate(43, $shouldRemoveOnTrailingIconClickStore = value));
  setContext("SMUI:chips:chip:shouldRemoveOnTrailingIconClick", shouldRemoveOnTrailingIconClickStore);
  const isSelectedStore = writable(selected);
  validate_store(isSelectedStore, "isSelectedStore");
  component_subscribe($$self, isSelectedStore, (value) => $$invalidate(42, $isSelectedStore = value));
  setContext("SMUI:chips:chip:isSelected", isSelectedStore);
  const leadingIconClassesStore = writable(leadingIconClasses);
  validate_store(leadingIconClassesStore, "leadingIconClassesStore");
  component_subscribe($$self, leadingIconClassesStore, (value) => $$invalidate(41, $leadingIconClassesStore = value));
  setContext("SMUI:chips:chip:leadingIconClasses", leadingIconClassesStore);
  setContext("SMUI:chips:chip:focusable", $choice && selected || $index === 0);
  if (!chipId) {
    throw new Error("The chip property is required! It should be passed down from the Set to the Chip.");
  }
  onMount(() => {
    $$invalidate(7, instance5 = new MDCChipFoundation({
      addClass,
      addClassToLeadingIcon: addLeadingIconClass,
      eventTargetHasClass: (target, className2) => target && "classList" in target ? target.classList.contains(className2) : false,
      focusPrimaryAction: () => {
        if (primaryActionAccessor) {
          primaryActionAccessor.focus();
        }
      },
      focusTrailingAction: () => {
        if (trailingActionAccessor) {
          trailingActionAccessor.focus();
        }
      },
      getAttribute: (attr) => getElement().getAttribute(attr),
      getCheckmarkBoundingClientRect: () => {
        const target = getElement().querySelector(".mdc-chip__checkmark");
        if (target) {
          return target.getBoundingClientRect();
        }
        return null;
      },
      getComputedStyleValue: getStyle,
      getRootBoundingClientRect: () => getElement().getBoundingClientRect(),
      hasClass,
      hasLeadingIcon: () => {
        const target = getElement().querySelector(".mdc-chip__icon--leading");
        return !!target;
      },
      isRTL: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
      isTrailingActionNavigable: () => {
        if (trailingActionAccessor) {
          return trailingActionAccessor.isNavigable();
        }
        return false;
      },
      notifyInteraction: () => dispatch(getElement(), "SMUIChip:interaction", { chipId }, void 0, true),
      notifyNavigation: (key, source) => dispatch(getElement(), "SMUIChip:navigation", { chipId, key, source }, void 0, true),
      notifyRemoval: (removedAnnouncement) => {
        dispatch(getElement(), "SMUIChip:removal", { chipId, removedAnnouncement }, void 0, true);
      },
      notifySelection: (selected2, shouldIgnore) => dispatch(getElement(), "SMUIChip:selection", { chipId, selected: selected2, shouldIgnore }, void 0, true),
      notifyTrailingIconInteraction: () => dispatch(getElement(), "SMUIChip:trailingIconInteraction", { chipId }, void 0, true),
      notifyEditStart: () => {
      },
      /* Not Implemented. */
      notifyEditFinish: () => {
      },
      /* Not Implemented. */
      removeClass,
      removeClassFromLeadingIcon: removeLeadingIconClass,
      removeTrailingActionFocus: () => {
        if (trailingActionAccessor) {
          trailingActionAccessor.removeFocus();
        }
      },
      setPrimaryActionAttr: (attr, value) => {
        if (primaryActionAccessor) {
          primaryActionAccessor.addAttr(attr, value);
        }
      },
      setStyleProperty: addStyle
    }));
    const accessor = {
      chipId,
      get selected() {
        return selected;
      },
      focusPrimaryAction,
      focusTrailingAction,
      removeFocus,
      setSelectedFromChipSet
    };
    dispatch(getElement(), "SMUIChipsChip:mount", accessor);
    instance5.init();
    return () => {
      dispatch(getElement(), "SMUIChipsChip:unmount", accessor);
      instance5.destroy();
    };
  });
  function handleSMUIChipsChipPrimaryAction(event) {
    $$invalidate(12, primaryActionAccessor = event.detail);
  }
  function handleSMUIChipsChipTrailingAction(event) {
    $$invalidate(13, trailingActionAccessor = event.detail);
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = false, internalClasses);
    }
  }
  function addLeadingIconClass(className2) {
    if (!leadingIconClasses[className2]) {
      $$invalidate(33, leadingIconClasses[className2] = true, leadingIconClasses);
    }
  }
  function removeLeadingIconClass(className2) {
    if (!(className2 in leadingIconClasses) || leadingIconClasses[className2]) {
      $$invalidate(33, leadingIconClasses[className2] = false, leadingIconClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(11, internalStyles);
      } else {
        $$invalidate(11, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getStyle(name) {
    return name in internalStyles ? internalStyles[name] : getComputedStyle(getElement()).getPropertyValue(name);
  }
  function setSelectedFromChipSet(value, shouldNotifyClients) {
    $$invalidate(8, selected = value);
    instance5.setSelectedFromChipSet(selected, shouldNotifyClients);
  }
  function focusPrimaryAction() {
    instance5.focusPrimaryAction();
  }
  function focusTrailingAction() {
    instance5.focusTrailingAction();
  }
  function removeFocus() {
    instance5.removeFocus();
  }
  function getElement() {
    return element2.getElement();
  }
  $$self.$$.on_mount.push(function() {
    if (chipId === void 0 && !("chip" in $$props || $$self.$$.bound[$$self.$$.props["chip"]])) {
      console.warn("<Chip> was created without expected prop 'chip'");
    }
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  const SMUIChipsChipPrimaryAction_unmount_handler = () => $$invalidate(12, primaryActionAccessor = void 0);
  const SMUIChipsChipTrailingAction_unmount_handler = () => $$invalidate(13, trailingActionAccessor = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("chip" in $$new_props)
      $$invalidate(29, chipId = $$new_props.chip);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$new_props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("shouldRemoveOnTrailingIconClick" in $$new_props)
      $$invalidate(30, shouldRemoveOnTrailingIconClick = $$new_props.shouldRemoveOnTrailingIconClick);
    if ("shouldFocusPrimaryActionOnClick" in $$new_props)
      $$invalidate(31, shouldFocusPrimaryActionOnClick = $$new_props.shouldFocusPrimaryActionOnClick);
    if ("component" in $$new_props)
      $$invalidate(5, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(6, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(38, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    setContext,
    getContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ripple: dist_default,
    SmuiElement: SmuiElement_default,
    MDCChipFoundation,
    forwardEvents,
    use,
    className,
    style,
    chipId,
    ripple,
    touch,
    shouldRemoveOnTrailingIconClick,
    shouldFocusPrimaryActionOnClick,
    element: element2,
    instance: instance5,
    internalClasses,
    leadingIconClasses,
    internalStyles,
    initialSelectedStore,
    selected,
    primaryActionAccessor,
    trailingActionAccessor,
    nonInteractive,
    choice,
    index,
    component,
    tag,
    shouldRemoveOnTrailingIconClickStore,
    isSelectedStore,
    leadingIconClassesStore,
    handleSMUIChipsChipPrimaryAction,
    handleSMUIChipsChipTrailingAction,
    hasClass,
    addClass,
    removeClass,
    addLeadingIconClass,
    removeLeadingIconClass,
    addStyle,
    getStyle,
    setSelectedFromChipSet,
    focusPrimaryAction,
    focusTrailingAction,
    removeFocus,
    getElement,
    $index,
    $choice,
    $leadingIconClassesStore,
    $isSelectedStore,
    $shouldRemoveOnTrailingIconClickStore,
    $initialSelectedStore,
    $nonInteractive
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("chipId" in $$props)
      $$invalidate(29, chipId = $$new_props.chipId);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("shouldRemoveOnTrailingIconClick" in $$props)
      $$invalidate(30, shouldRemoveOnTrailingIconClick = $$new_props.shouldRemoveOnTrailingIconClick);
    if ("shouldFocusPrimaryActionOnClick" in $$props)
      $$invalidate(31, shouldFocusPrimaryActionOnClick = $$new_props.shouldFocusPrimaryActionOnClick);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(7, instance5 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(10, internalClasses = $$new_props.internalClasses);
    if ("leadingIconClasses" in $$props)
      $$invalidate(33, leadingIconClasses = $$new_props.leadingIconClasses);
    if ("internalStyles" in $$props)
      $$invalidate(11, internalStyles = $$new_props.internalStyles);
    if ("selected" in $$props)
      $$invalidate(8, selected = $$new_props.selected);
    if ("primaryActionAccessor" in $$props)
      $$invalidate(12, primaryActionAccessor = $$new_props.primaryActionAccessor);
    if ("trailingActionAccessor" in $$props)
      $$invalidate(13, trailingActionAccessor = $$new_props.trailingActionAccessor);
    if ("component" in $$props)
      $$invalidate(5, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(6, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*shouldRemoveOnTrailingIconClick*/
    1073741824) {
      $:
        set_store_value(shouldRemoveOnTrailingIconClickStore, $shouldRemoveOnTrailingIconClickStore = shouldRemoveOnTrailingIconClick, $shouldRemoveOnTrailingIconClickStore);
    }
    if ($$self.$$.dirty[0] & /*selected*/
    256) {
      $:
        set_store_value(isSelectedStore, $isSelectedStore = selected, $isSelectedStore);
    }
    if ($$self.$$.dirty[1] & /*leadingIconClasses*/
    4) {
      $:
        set_store_value(leadingIconClassesStore, $leadingIconClassesStore = leadingIconClasses, $leadingIconClassesStore);
    }
    if ($$self.$$.dirty[0] & /*instance, shouldRemoveOnTrailingIconClick*/
    1073741952) {
      $:
        if (instance5 && instance5.getShouldRemoveOnTrailingIconClick() !== shouldRemoveOnTrailingIconClick) {
          instance5.setShouldRemoveOnTrailingIconClick(shouldRemoveOnTrailingIconClick);
        }
    }
    if ($$self.$$.dirty[0] & /*instance*/
    128 | $$self.$$.dirty[1] & /*shouldFocusPrimaryActionOnClick*/
    1) {
      $:
        if (instance5) {
          instance5.setShouldFocusPrimaryActionOnClick(shouldFocusPrimaryActionOnClick);
        }
    }
  };
  return [
    use,
    className,
    style,
    ripple,
    touch,
    component,
    tag,
    instance5,
    selected,
    element2,
    internalClasses,
    internalStyles,
    primaryActionAccessor,
    trailingActionAccessor,
    $nonInteractive,
    forwardEvents,
    initialSelectedStore,
    nonInteractive,
    choice,
    index,
    shouldRemoveOnTrailingIconClickStore,
    isSelectedStore,
    leadingIconClassesStore,
    handleSMUIChipsChipPrimaryAction,
    handleSMUIChipsChipTrailingAction,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    chipId,
    shouldRemoveOnTrailingIconClick,
    shouldFocusPrimaryActionOnClick,
    getElement,
    leadingIconClasses,
    slots,
    switch_instance_binding,
    SMUIChipsChipPrimaryAction_unmount_handler,
    SMUIChipsChipTrailingAction_unmount_handler,
    $$scope
  ];
}
var Chip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        chip: 29,
        ripple: 3,
        touch: 4,
        shouldRemoveOnTrailingIconClick: 30,
        shouldFocusPrimaryActionOnClick: 31,
        component: 5,
        tag: 6,
        getElement: 32
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chip",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chip() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chip(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touch() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touch(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldRemoveOnTrailingIconClick() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldRemoveOnTrailingIconClick(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFocusPrimaryActionOnClick() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFocusPrimaryActionOnClick(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[32];
  }
  set getElement(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chip_default = Chip;

// node_modules/@smui/chips/dist/Set.svelte
var file2 = "node_modules\\@smui\\chips\\dist\\Set.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  child_ctx[39] = i;
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ chip: dirty[0] & /*chips*/
1 });
var get_default_slot_context = (ctx) => ({ chip: (
  /*chip*/
  ctx[37]
) });
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, chips*/
        134217729)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(24:6) <ContextFragment         key=\\"SMUI:chips:chip:initialSelected\\"         value={initialSelected[i]}       >',
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let contextfragment;
  let t;
  let current;
  contextfragment = new ContextFragment_default({
    props: {
      key: "SMUI:chips:chip:initialSelected",
      value: (
        /*initialSelected*/
        ctx[10][
          /*i*/
          ctx[39]
        ]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(contextfragment.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(contextfragment.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contextfragment, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextfragment_changes = {};
      if (dirty[0] & /*chips*/
      1)
        contextfragment_changes.value = /*initialSelected*/
        ctx2[10][
          /*i*/
          ctx2[39]
        ];
      if (dirty[0] & /*$$scope, chips*/
      134217729) {
        contextfragment_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment.$set(contextfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contextfragment, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(23:4) <ContextFragment key=\\"SMUI:chips:chip:index\\" value={i}>',
    ctx
  });
  return block;
}
function create_each_block(key_2, ctx) {
  let first;
  let contextfragment;
  let current;
  contextfragment = new ContextFragment_default({
    props: {
      key: "SMUI:chips:chip:index",
      value: (
        /*i*/
        ctx[39]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_2,
    first: null,
    c: function create() {
      first = empty();
      create_component(contextfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(contextfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(contextfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const contextfragment_changes = {};
      if (dirty[0] & /*chips*/
      1)
        contextfragment_changes.value = /*i*/
        ctx[39];
      if (dirty[0] & /*$$scope, chips*/
      134217729) {
        contextfragment_changes.$$scope = { dirty, ctx };
      }
      contextfragment.$set(contextfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(contextfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:2) {#each chips as chip, i (key(chip))}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*chips*/
    ctx[0]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*key*/
    ctx2[3](
      /*chip*/
      ctx2[37]
    )
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-chip-set": true,
        "smui-chip-set--non-interactive": (
          /*nonInteractive*/
          ctx[4]
        ),
        "mdc-chip-set--choice": (
          /*choice*/
          ctx[5]
        ),
        "mdc-chip-set--filter": (
          /*filter*/
          ctx[6]
        ),
        "mdc-chip-set--input": (
          /*input*/
          ctx[7]
        )
      })
    },
    { role: "grid" },
    /*$$restProps*/
    ctx[20]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[26](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[9].call(null, div)),
          listen_dev(
            div,
            "SMUIChipsChip:mount",
            /*handleChipMount*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChipsChip:unmount",
            /*handleChipUnmount*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:interaction",
            /*handleChipInteraction*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:selection",
            /*handleChipSelection*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:removal",
            /*handleChipRemoval*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:navigation",
            /*handleChipNavigation*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*chips, initialSelected, $$scope, key*/
      134218761) {
        each_value = /*chips*/
        ctx2[0];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className, nonInteractive, choice, filter, input*/
        244 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx2[2]
          ]: true,
          "mdc-chip-set": true,
          "smui-chip-set--non-interactive": (
            /*nonInteractive*/
            ctx2[4]
          ),
          "mdc-chip-set--choice": (
            /*choice*/
            ctx2[5]
          ),
          "mdc-chip-set--filter": (
            /*filter*/
            ctx2[6]
          ),
          "mdc-chip-set--input": (
            /*input*/
            ctx2[7]
          )
        }))) && { class: div_class_value },
        { role: "grid" },
        dirty[0] & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx2[20]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function setDifference(setA, setB) {
  let _difference = new Set(setA);
  for (let elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "chips",
    "key",
    "selected",
    "nonInteractive",
    "choice",
    "filter",
    "input",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $filterStore;
  let $choiceStore;
  let $nonInteractiveStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Set", slots, ["default"]);
  const { MDCChipSetFoundation } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { chips = [] } = $$props;
  let { key = (chip) => chip } = $$props;
  let { selected = void 0 } = $$props;
  let { nonInteractive = false } = $$props;
  let { choice = false } = $$props;
  let { filter = false } = $$props;
  let { input = false } = $$props;
  let element2;
  let instance5;
  let chipAccessorMap = {};
  let chipAccessorWeakMap = /* @__PURE__ */ new WeakMap();
  let initialSelected = chips.map((chipId) => choice && selected === chipId || filter && selected.indexOf(chipId) !== -1);
  const nonInteractiveStore = writable(nonInteractive);
  validate_store(nonInteractiveStore, "nonInteractiveStore");
  component_subscribe($$self, nonInteractiveStore, (value) => $$invalidate(31, $nonInteractiveStore = value));
  setContext("SMUI:chips:nonInteractive", nonInteractiveStore);
  const choiceStore = writable(choice);
  validate_store(choiceStore, "choiceStore");
  component_subscribe($$self, choiceStore, (value) => $$invalidate(30, $choiceStore = value));
  setContext("SMUI:chips:choice", choiceStore);
  const filterStore = writable(filter);
  validate_store(filterStore, "filterStore");
  component_subscribe($$self, filterStore, (value) => $$invalidate(29, $filterStore = value));
  setContext("SMUI:chips:filter", filterStore);
  let previousSelected = filter ? new Set(selected) : selected;
  onMount(() => {
    $$invalidate(23, instance5 = new MDCChipSetFoundation({
      announceMessage: announce,
      focusChipPrimaryActionAtIndex: (index) => {
        var _a;
        (_a = getAccessor(chips[index])) === null || _a === void 0 ? void 0 : _a.focusPrimaryAction();
      },
      focusChipTrailingActionAtIndex: (index) => {
        var _a;
        (_a = getAccessor(chips[index])) === null || _a === void 0 ? void 0 : _a.focusTrailingAction();
      },
      getChipListCount: () => chips.length,
      getIndexOfChipById: (chipId) => chips.indexOf(chipId),
      hasClass: (className2) => getElement().classList.contains(className2),
      isRTL: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
      removeChipAtIndex: (index) => {
        if (index >= 0 && index < chips.length) {
          if (choice && selected === chips[index]) {
            $$invalidate(21, selected = null);
          } else if (filter && selected.indexOf(chips[index]) !== -1) {
            selected.splice(selected.indexOf(chips[index]), 1);
            $$invalidate(21, selected);
          }
          chips.splice(index, 1);
          $$invalidate(0, chips);
        }
      },
      removeFocusFromChipAtIndex: (index) => {
        var _a;
        (_a = getAccessor(chips[index])) === null || _a === void 0 ? void 0 : _a.removeFocus();
      },
      selectChipAtIndex: (index, selectedValue, shouldNotifyClients) => {
        var _a;
        if (index >= 0 && index < chips.length) {
          if (filter) {
            const selIndex = selected.indexOf(chips[index]);
            if (selectedValue && selIndex === -1) {
              selected.push(chips[index]);
              $$invalidate(21, selected);
            } else if (!selectedValue && selIndex !== -1) {
              selected.splice(selIndex, 1);
              $$invalidate(21, selected);
            }
          } else if (choice && (selectedValue || selected === chips[index])) {
            $$invalidate(21, selected = selectedValue ? chips[index] : null);
          }
          (_a = getAccessor(chips[index])) === null || _a === void 0 ? void 0 : _a.setSelectedFromChipSet(selectedValue, shouldNotifyClients);
        }
      }
    }));
    instance5.init();
    if (choice && selected != null) {
      instance5.select(selected);
    } else if (filter && selected.length) {
      for (const chipId of selected) {
        instance5.select(chipId);
      }
    }
    return () => {
      instance5.destroy();
    };
  });
  function handleChipMount(event) {
    const accessor = event.detail;
    addAccessor(accessor.chipId, accessor);
  }
  function handleChipUnmount(event) {
    const accessor = event.detail;
    removeAccessor(accessor.chipId);
  }
  function handleChipInteraction(event) {
    if (instance5) {
      instance5.handleChipInteraction(event.detail);
    }
  }
  function handleChipSelection(event) {
    if (instance5) {
      instance5.handleChipSelection(event.detail);
    }
  }
  function handleChipRemoval(event) {
    if (instance5) {
      instance5.handleChipRemoval(event.detail);
    }
  }
  function handleChipNavigation(event) {
    if (instance5) {
      instance5.handleChipNavigation(event.detail);
    }
  }
  function getAccessor(chipId) {
    return chipId instanceof Object ? chipAccessorWeakMap.get(chipId) : chipAccessorMap[chipId];
  }
  function addAccessor(chipId, accessor) {
    if (chipId instanceof Object) {
      chipAccessorWeakMap.set(chipId, accessor);
    } else {
      chipAccessorMap[chipId] = accessor;
    }
  }
  function removeAccessor(chipId) {
    if (chipId instanceof Object) {
      chipAccessorWeakMap.delete(chipId);
    } else {
      delete chipAccessorMap[chipId];
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("chips" in $$new_props)
      $$invalidate(0, chips = $$new_props.chips);
    if ("key" in $$new_props)
      $$invalidate(3, key = $$new_props.key);
    if ("selected" in $$new_props)
      $$invalidate(21, selected = $$new_props.selected);
    if ("nonInteractive" in $$new_props)
      $$invalidate(4, nonInteractive = $$new_props.nonInteractive);
    if ("choice" in $$new_props)
      $$invalidate(5, choice = $$new_props.choice);
    if ("filter" in $$new_props)
      $$invalidate(6, filter = $$new_props.filter);
    if ("input" in $$new_props)
      $$invalidate(7, input = $$new_props.input);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    setContext,
    writable,
    get_current_component,
    announce,
    forwardEventsBuilder,
    classMap,
    useActions,
    ContextFragment: ContextFragment_default,
    MDCChipSetFoundation,
    forwardEvents,
    use,
    className,
    chips,
    key,
    selected,
    nonInteractive,
    choice,
    filter,
    input,
    element: element2,
    instance: instance5,
    chipAccessorMap,
    chipAccessorWeakMap,
    initialSelected,
    nonInteractiveStore,
    choiceStore,
    filterStore,
    previousSelected,
    setDifference,
    handleChipMount,
    handleChipUnmount,
    handleChipInteraction,
    handleChipSelection,
    handleChipRemoval,
    handleChipNavigation,
    getAccessor,
    addAccessor,
    removeAccessor,
    getElement,
    $filterStore,
    $choiceStore,
    $nonInteractiveStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("chips" in $$props)
      $$invalidate(0, chips = $$new_props.chips);
    if ("key" in $$props)
      $$invalidate(3, key = $$new_props.key);
    if ("selected" in $$props)
      $$invalidate(21, selected = $$new_props.selected);
    if ("nonInteractive" in $$props)
      $$invalidate(4, nonInteractive = $$new_props.nonInteractive);
    if ("choice" in $$props)
      $$invalidate(5, choice = $$new_props.choice);
    if ("filter" in $$props)
      $$invalidate(6, filter = $$new_props.filter);
    if ("input" in $$props)
      $$invalidate(7, input = $$new_props.input);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(23, instance5 = $$new_props.instance);
    if ("chipAccessorMap" in $$props)
      chipAccessorMap = $$new_props.chipAccessorMap;
    if ("chipAccessorWeakMap" in $$props)
      chipAccessorWeakMap = $$new_props.chipAccessorWeakMap;
    if ("initialSelected" in $$props)
      $$invalidate(10, initialSelected = $$new_props.initialSelected);
    if ("previousSelected" in $$props)
      $$invalidate(24, previousSelected = $$new_props.previousSelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*nonInteractive*/
    16) {
      $:
        set_store_value(nonInteractiveStore, $nonInteractiveStore = nonInteractive, $nonInteractiveStore);
    }
    if ($$self.$$.dirty[0] & /*choice*/
    32) {
      $:
        set_store_value(choiceStore, $choiceStore = choice, $choiceStore);
    }
    if ($$self.$$.dirty[0] & /*filter*/
    64) {
      $:
        set_store_value(filterStore, $filterStore = filter, $filterStore);
    }
    if ($$self.$$.dirty[0] & /*instance, choice, previousSelected, selected*/
    27263008) {
      $:
        if (instance5 && choice && previousSelected !== selected) {
          $$invalidate(24, previousSelected = selected);
          instance5.select(selected);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, filter, selected, previousSelected, chips*/
    27263041) {
      $:
        if (instance5 && filter) {
          const setSelected = new Set(selected);
          const unSelected = setDifference(previousSelected, setSelected);
          const newSelected = setDifference(setSelected, previousSelected);
          if (unSelected.size || newSelected.size) {
            $$invalidate(24, previousSelected = setSelected);
            for (let chipId of unSelected) {
              if (chips.indexOf(chipId) !== -1) {
                instance5.handleChipSelection({ chipId, selected: false });
              }
            }
            for (let chipId of newSelected) {
              instance5.handleChipSelection({ chipId, selected: true });
            }
          }
        }
    }
  };
  return [
    chips,
    use,
    className,
    key,
    nonInteractive,
    choice,
    filter,
    input,
    element2,
    forwardEvents,
    initialSelected,
    nonInteractiveStore,
    choiceStore,
    filterStore,
    handleChipMount,
    handleChipUnmount,
    handleChipInteraction,
    handleChipSelection,
    handleChipRemoval,
    handleChipNavigation,
    $$restProps,
    selected,
    getElement,
    instance5,
    previousSelected,
    slots,
    div_binding,
    $$scope
  ];
}
var Set_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_12,
      create_fragment2,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        chips: 0,
        key: 3,
        selected: 21,
        nonInteractive: 4,
        choice: 5,
        filter: 6,
        input: 7,
        getElement: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Set_1",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chips() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chips(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get choice() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set choice(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[22];
  }
  set getElement(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Set_default = Set_1;

// node_modules/@smui/chips/dist/Checkmark.svelte
var file3 = "node_modules\\@smui\\chips\\dist\\Checkmark.svelte";
function create_fragment3(ctx) {
  let span;
  let svg;
  let path;
  let span_class_value;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    {
      class: span_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__checkmark": true
      })
    },
    /*$$restProps*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        class: true,
        fill: true,
        stroke: true,
        d: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "mdc-chip__checkmark-path");
      attr_dev(path, "fill", "none");
      attr_dev(path, "stroke", "black");
      attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
      add_location(path, file3, 10, 4, 220);
      attr_dev(svg, "class", "mdc-chip__checkmark-svg");
      attr_dev(svg, "viewBox", "-2 -3 30 30");
      add_location(svg, file3, 9, 2, 156);
      set_attributes(span, span_data);
      add_location(span, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, svg);
      append_hydration_dev(svg, path);
      ctx[5](span);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*use*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*className*/
        2 && span_class_value !== (span_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__checkmark": true
        })) && { class: span_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkmark", slots, []);
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
  };
  $$self.$capture_state = () => ({
    classMap,
    useActions,
    use,
    className,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, className, element2, $$restProps, getElement, span_binding];
}
var Checkmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkmark",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[4];
  }
  set getElement(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkmark_default = Checkmark;

// node_modules/@smui/chips/dist/Text.svelte
var file4 = "node_modules\\@smui\\chips\\dist\\Text.svelte";
function create_if_block_12(ctx) {
  let checkmark;
  let current;
  let checkmark_props = {};
  checkmark = new Checkmark_default({ props: checkmark_props, $$inline: true });
  ctx[23](checkmark);
  const block = {
    c: function create() {
      create_component(checkmark.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmark.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmark, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmark_changes = {};
      checkmark.$set(checkmark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[23](null);
      destroy_component(checkmark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(1:0) {#if $filter}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let span1;
  let span0;
  let span1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__primary-action": true
      })
    },
    /*$filter*/
    ctx[3] || /*$choice*/
    ctx[2] ? {
      "aria-selected": (
        /*$isSelected*/
        ctx[10] ? "true" : "false"
      )
    } : {},
    /*roleProps*/
    ctx[8],
    /*internalAttrs*/
    ctx[7],
    /*$$restProps*/
    ctx[16]
  ];
  let span_data_1 = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "mdc-chip__text");
      add_location(span0, file4, 23, 23, 547);
      set_attributes(span1, span_data_1);
      add_location(span1, file4, 12, 4, 232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      ctx[24](span1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        (!current || dirty & /*className*/
        2 && span1_class_value !== (span1_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__primary-action": true
        }))) && { class: span1_class_value },
        dirty & /*$filter, $choice, $isSelected*/
        1036 && /*$filter*/
        (ctx2[3] || /*$choice*/
        ctx2[2] ? {
          "aria-selected": (
            /*$isSelected*/
            ctx2[10] ? "true" : "false"
          )
        } : {}),
        dirty & /*roleProps*/
        256 && /*roleProps*/
        ctx2[8],
        dirty & /*internalAttrs*/
        128 && /*internalAttrs*/
        ctx2[7],
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx2[16]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(12:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-chip__text");
      add_location(span, file4, 10, 4, 173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(10:2) {#if $nonInteractive}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let t;
  let span;
  let current_block_type_index;
  let if_block1;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$filter*/
    ctx[3] && create_if_block_12(ctx)
  );
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$nonInteractive*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      span = element("span");
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { role: true });
      var span_nodes = children(span);
      if_block1.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "role", "gridcell");
      add_location(span, file4, 3, 0, 54);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      ctx[25](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$filter*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$filter*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(span, null);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(span);
      if_blocks[current_block_type_index].d();
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let roleProps;
  const omit_props_names = ["use", "class", "tabindex", "focus", "getInput", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $choice;
  let $filter;
  let $nonInteractive;
  let $isSelected;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { tabindex = getContext("SMUI:chips:chip:focusable") ? 0 : -1 } = $$props;
  let element2;
  let input = void 0;
  let primaryAction = void 0;
  let internalAttrs = {};
  const nonInteractive = getContext("SMUI:chips:nonInteractive");
  validate_store(nonInteractive, "nonInteractive");
  component_subscribe($$self, nonInteractive, (value) => $$invalidate(9, $nonInteractive = value));
  const choice = getContext("SMUI:chips:choice");
  validate_store(choice, "choice");
  component_subscribe($$self, choice, (value) => $$invalidate(2, $choice = value));
  const filter = getContext("SMUI:chips:filter");
  validate_store(filter, "filter");
  component_subscribe($$self, filter, (value) => $$invalidate(3, $filter = value));
  const isSelected = getContext("SMUI:chips:chip:isSelected");
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value) => $$invalidate(10, $isSelected = value));
  onMount(() => {
    let accessor = { focus, addAttr };
    dispatch(getElement(), "SMUIChipsChipPrimaryAction:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIChipsChipPrimaryAction:unmount", accessor);
    };
  });
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(7, internalAttrs[name] = value, internalAttrs);
    }
  }
  function waitForTabindex(fn) {
    if (internalAttrs["tabindex"] !== element2.getAttribute("tabindex")) {
      tick().then(fn);
    } else {
      fn();
    }
  }
  function focus() {
    waitForTabindex(() => {
      primaryAction && primaryAction.focus();
    });
  }
  function getInput() {
    return input && input.getElement();
  }
  function getElement() {
    return element2;
  }
  function checkmark_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(5, input);
    });
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      primaryAction = $$value;
      $$invalidate(6, primaryAction);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("tabindex" in $$new_props)
      $$invalidate(17, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    getContext,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    Checkmark: Checkmark_default,
    forwardEvents,
    use,
    className,
    tabindex,
    element: element2,
    input,
    primaryAction,
    internalAttrs,
    nonInteractive,
    choice,
    filter,
    isSelected,
    addAttr,
    waitForTabindex,
    focus,
    getInput,
    getElement,
    roleProps,
    $choice,
    $filter,
    $nonInteractive,
    $isSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("tabindex" in $$props)
      $$invalidate(17, tabindex = $$new_props.tabindex);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("input" in $$props)
      $$invalidate(5, input = $$new_props.input);
    if ("primaryAction" in $$props)
      $$invalidate(6, primaryAction = $$new_props.primaryAction);
    if ("internalAttrs" in $$props)
      $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
    if ("roleProps" in $$props)
      $$invalidate(8, roleProps = $$new_props.roleProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$filter, $choice, tabindex*/
    131084) {
      $:
        $$invalidate(8, roleProps = {
          role: $filter ? "checkbox" : $choice ? "radio" : "button",
          tabindex
        });
    }
  };
  return [
    use,
    className,
    $choice,
    $filter,
    element2,
    input,
    primaryAction,
    internalAttrs,
    roleProps,
    $nonInteractive,
    $isSelected,
    forwardEvents,
    nonInteractive,
    choice,
    filter,
    isSelected,
    $$restProps,
    tabindex,
    focus,
    getInput,
    getElement,
    $$scope,
    slots,
    checkmark_binding,
    span1_binding,
    span_binding
  ];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      tabindex: 17,
      focus: 18,
      getInput: 19,
      getElement: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[18];
  }
  set focus(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getInput() {
    return this.$$.ctx[19];
  }
  set getInput(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[20];
  }
  set getElement(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/@smui/chips/dist/LeadingIcon.svelte
var file5 = "node_modules\\@smui\\chips\\dist\\LeadingIcon.svelte";
function create_fragment5(ctx) {
  let i;
  let i_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let i_levels = [
    {
      class: i_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__icon": true,
        "mdc-chip__icon--leading": true,
        "mdc-chip__icon--leading-hidden": (
          /*$filter*/
          ctx[3] && /*$isSelected*/
          ctx[4]
        ),
        .../*$leadingIconClasses*/
        ctx[5]
      })
    },
    /*$$restProps*/
    ctx[10]
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      var i_nodes = children(i);
      if (default_slot)
        default_slot.l(i_nodes);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(i, i_data);
      add_location(i, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[14](i);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            i,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, i))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*className, $filter, $isSelected, $leadingIconClasses*/
        58 && i_class_value !== (i_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__icon": true,
          "mdc-chip__icon--leading": true,
          "mdc-chip__icon--leading-hidden": (
            /*$filter*/
            ctx2[3] && /*$isSelected*/
            ctx2[4]
          ),
          .../*$leadingIconClasses*/
          ctx2[5]
        }))) && { class: i_class_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $filter;
  let $isSelected;
  let $leadingIconClasses;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LeadingIcon", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  const filter = getContext("SMUI:chips:filter");
  validate_store(filter, "filter");
  component_subscribe($$self, filter, (value) => $$invalidate(3, $filter = value));
  const isSelected = getContext("SMUI:chips:chip:isSelected");
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value) => $$invalidate(4, $isSelected = value));
  const leadingIconClasses = getContext("SMUI:chips:chip:leadingIconClasses");
  validate_store(leadingIconClasses, "leadingIconClasses");
  component_subscribe($$self, leadingIconClasses, (value) => $$invalidate(5, $leadingIconClasses = value));
  let element2;
  function getElement() {
    return element2;
  }
  function i_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    filter,
    isSelected,
    leadingIconClasses,
    element: element2,
    getElement,
    $filter,
    $isSelected,
    $leadingIconClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    $filter,
    $isSelected,
    $leadingIconClasses,
    forwardEvents,
    filter,
    isSelected,
    leadingIconClasses,
    $$restProps,
    getElement,
    $$scope,
    slots,
    i_binding
  ];
}
var LeadingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment5, safe_not_equal, { use: 0, class: 1, getElement: 11 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LeadingIcon",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<LeadingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LeadingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LeadingIcon_default = LeadingIcon;

// node_modules/@smui/chips/dist/TrailingIcon.svelte
var file6 = "node_modules\\@smui\\chips\\dist\\TrailingIcon.svelte";
function create_fragment6(ctx) {
  let span;
  let i;
  let i_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let i_levels = [
    {
      class: i_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__icon": true,
        "mdc-chip__icon--trailing": true
      })
    },
    /*$$restProps*/
    ctx[4]
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      span = element("span");
      i = element("i");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { role: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      var i_nodes = children(i);
      if (default_slot)
        default_slot.l(i_nodes);
      i_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(i, i_data);
      add_location(i, file6, 6, 2, 93);
      attr_dev(span, "role", "gridcell");
      add_location(span, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, i);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[8](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*className*/
        2 && i_class_value !== (i_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__icon": true,
          "mdc-chip__icon--trailing": true
        }))) && { class: i_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrailingIcon", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
var TrailingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment6, safe_not_equal, { use: 0, class: 1, getElement: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrailingIcon",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error("<TrailingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrailingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  set getElement(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrailingIcon_default = TrailingIcon;

// node_modules/@smui/chips/dist/TrailingAction.svelte
var file7 = "node_modules\\@smui\\chips\\dist\\TrailingAction.svelte";
function create_if_block3(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-deprecated-chip-trailing-action__touch");
      add_location(span, file7, 30, 4, 773);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(30:2) {#if touch}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let button;
  let span0;
  let t0;
  let t1;
  let span1;
  let span1_class_value;
  let useActions_action;
  let button_class_value;
  let button_style_value;
  let button_aria_hidden_value;
  let Ripple_action;
  let useActions_action_1;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*touch*/
    ctx[4] && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*icon$class*/
          ctx[7]
        ]: true,
        "mdc-deprecated-chip-trailing-action__icon": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[17],
      "icon$"
    )
  ];
  let span_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data = assign(span_data, span1_levels[i]);
  }
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-chip-trailing-action": true,
        .../*internalClasses*/
        ctx[10]
      })
    },
    {
      style: button_style_value = Object.entries(
        /*internalStyles*/
        ctx[11]
      ).map(func2).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    {
      "aria-hidden": button_aria_hidden_value = /*nonNavigable*/
      ctx[5] ? "true" : void 0
    },
    { tabindex: "-1" },
    /*internalAttrs*/
    ctx[12],
    exclude(
      /*$$restProps*/
      ctx[17],
      ["icon$"]
    )
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      span1 = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        style: true,
        "aria-hidden": true,
        tabindex: true
      });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(button_nodes);
      if (if_block)
        if_block.l(button_nodes);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      if (default_slot)
        default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "mdc-deprecated-chip-trailing-action__ripple");
      add_location(span0, file7, 28, 2, 694);
      set_attributes(span1, span_data);
      add_location(span1, file7, 32, 2, 843);
      set_attributes(button, button_data);
      add_location(button, file7, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span0);
      append_hydration_dev(button, t0);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[24](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*icon$use*/
            ctx[6]
          )),
          action_destroyer(Ripple_action = dist_default.call(null, button, {
            ripple: (
              /*ripple*/
              ctx[3]
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[14]
            ),
            removeClass: (
              /*removeClass*/
              ctx[15]
            ),
            addStyle: (
              /*addStyle*/
              ctx[16]
            )
          })),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[13].call(null, button)),
          listen_dev(
            button,
            "click",
            function() {
              if (is_function(
                /*instance*/
                ctx[9] && /*instance*/
                ctx[9].handleClick.bind(
                  /*instance*/
                  ctx[9]
                )
              ))
                /*instance*/
                (ctx[9] && /*instance*/
                ctx[9].handleClick.bind(
                  /*instance*/
                  ctx[9]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[9] && /*instance*/
                ctx[9].handleKeydown.bind(
                  /*instance*/
                  ctx[9]
                )
              ))
                /*instance*/
                (ctx[9] && /*instance*/
                ctx[9].handleKeydown.bind(
                  /*instance*/
                  ctx[9]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*touch*/
        ctx[4]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block3(ctx);
          if_block.c();
          if_block.m(button, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span_data = get_spread_update(span1_levels, [
        (!current || dirty & /*icon$class*/
        128 && span1_class_value !== (span1_class_value = classMap({
          [
            /*icon$class*/
            ctx[7]
          ]: true,
          "mdc-deprecated-chip-trailing-action__icon": true
        }))) && { class: span1_class_value },
        dirty & /*$$restProps*/
        131072 && prefixFilter(
          /*$$restProps*/
          ctx[17],
          "icon$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*icon$use*/
      64)
        useActions_action.update.call(
          null,
          /*icon$use*/
          ctx[6]
        );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*className, internalClasses*/
        1026 && button_class_value !== (button_class_value = classMap({
          [
            /*className*/
            ctx[1]
          ]: true,
          "mdc-deprecated-chip-trailing-action": true,
          .../*internalClasses*/
          ctx[10]
        }))) && { class: button_class_value },
        (!current || dirty & /*internalStyles, style*/
        2052 && button_style_value !== (button_style_value = Object.entries(
          /*internalStyles*/
          ctx[11]
        ).map(func2).concat([
          /*style*/
          ctx[2]
        ]).join(" "))) && { style: button_style_value },
        (!current || dirty & /*nonNavigable*/
        32 && button_aria_hidden_value !== (button_aria_hidden_value = /*nonNavigable*/
        ctx[5] ? "true" : void 0)) && { "aria-hidden": button_aria_hidden_value },
        { tabindex: "-1" },
        dirty & /*internalAttrs*/
        4096 && /*internalAttrs*/
        ctx[12],
        dirty & /*$$restProps*/
        131072 && exclude(
          /*$$restProps*/
          ctx[17],
          ["icon$"]
        )
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple*/
      8)
        Ripple_action.update.call(null, {
          ripple: (
            /*ripple*/
            ctx[3]
          ),
          unbounded: false,
          addClass: (
            /*addClass*/
            ctx[14]
          ),
          removeClass: (
            /*removeClass*/
            ctx[15]
          ),
          addStyle: (
            /*addStyle*/
            ctx[16]
          )
        });
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/
      1)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "touch",
    "nonNavigable",
    "icon$use",
    "icon$class",
    "isNavigable",
    "focus",
    "removeFocus",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrailingAction", slots, ["default"]);
  const { MDCChipTrailingActionFoundation } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { touch = false } = $$props;
  let { nonNavigable = false } = $$props;
  let { icon$use = [] } = $$props;
  let { icon$class = "" } = $$props;
  let element2;
  let instance5;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  onMount(() => {
    $$invalidate(9, instance5 = new MDCChipTrailingActionFoundation({
      focus: () => {
        const element3 = getElement();
        waitForTabindex(() => {
          element3.focus();
        });
      },
      getAttribute: getAttr,
      notifyInteraction: (trigger) => dispatch(getElement(), "SMUIChipTrailingAction:interaction", { trigger }, void 0, true),
      notifyNavigation: (key) => {
        dispatch(getElement(), "SMUIChipTrailingAction:navigation", { key }, void 0, true);
      },
      setAttribute: addAttr
    }));
    const accessor = { isNavigable, focus, removeFocus };
    dispatch(getElement(), "SMUIChipsChipTrailingAction:mount", accessor);
    instance5.init();
    return () => {
      dispatch(getElement(), "SMUIChipsChipTrailingAction:unmount", accessor);
      instance5.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(11, internalStyles);
      } else {
        $$invalidate(11, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(12, internalAttrs[name] = value, internalAttrs);
    }
  }
  function waitForTabindex(fn) {
    if (internalAttrs["tabindex"] !== element2.getAttribute("tabindex")) {
      tick().then(fn);
    } else {
      fn();
    }
  }
  function isNavigable() {
    return instance5.isNavigable();
  }
  function focus() {
    instance5.focus();
  }
  function removeFocus() {
    instance5.removeFocus();
  }
  function getElement() {
    return element2;
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$new_props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("nonNavigable" in $$new_props)
      $$invalidate(5, nonNavigable = $$new_props.nonNavigable);
    if ("icon$use" in $$new_props)
      $$invalidate(6, icon$use = $$new_props.icon$use);
    if ("icon$class" in $$new_props)
      $$invalidate(7, icon$class = $$new_props.icon$class);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    MDCChipTrailingActionFoundation,
    forwardEvents,
    use,
    className,
    style,
    ripple,
    touch,
    nonNavigable,
    icon$use,
    icon$class,
    element: element2,
    instance: instance5,
    internalClasses,
    internalStyles,
    internalAttrs,
    addClass,
    removeClass,
    addStyle,
    getAttr,
    addAttr,
    waitForTabindex,
    isNavigable,
    focus,
    removeFocus,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("nonNavigable" in $$props)
      $$invalidate(5, nonNavigable = $$new_props.nonNavigable);
    if ("icon$use" in $$props)
      $$invalidate(6, icon$use = $$new_props.icon$use);
    if ("icon$class" in $$props)
      $$invalidate(7, icon$class = $$new_props.icon$class);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(9, instance5 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(10, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(11, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(12, internalAttrs = $$new_props.internalAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    ripple,
    touch,
    nonNavigable,
    icon$use,
    icon$class,
    element2,
    instance5,
    internalClasses,
    internalStyles,
    internalAttrs,
    forwardEvents,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    isNavigable,
    focus,
    removeFocus,
    getElement,
    $$scope,
    slots,
    button_binding
  ];
}
var TrailingAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment7, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      ripple: 3,
      touch: 4,
      nonNavigable: 5,
      icon$use: 6,
      icon$class: 7,
      isNavigable: 18,
      focus: 19,
      removeFocus: 20,
      getElement: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrailingAction",
      options,
      id: create_fragment7.name
    });
  }
  get use() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touch() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touch(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonNavigable() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonNavigable(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon$use() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon$use(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon$class() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon$class(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isNavigable() {
    return this.$$.ctx[18];
  }
  set isNavigable(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[19];
  }
  set focus(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeFocus() {
    return this.$$.ctx[20];
  }
  set removeFocus(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[21];
  }
  set getElement(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrailingAction_default = TrailingAction;

// node_modules/@smui/chips/dist/index.js
var dist_default2 = Chip_default;
export {
  LeadingIcon_default as LeadingIcon,
  Set_default as Set,
  Text_default as Text,
  TrailingAction_default as TrailingAction,
  TrailingIcon_default as TrailingIcon,
  dist_default2 as default
};
//# sourceMappingURL=@smui_chips.js.map
